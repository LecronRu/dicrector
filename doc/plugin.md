Формат — именованная конфигурация процесса обработки. Имя задается названием модуля в котором она описана. 
Выбор нужного формата в цепочке обработки, задается расширением файла данных — словаря.

Расширенное конфигурирование осуществляется наследованием реализованных классов словарей, правил, шаблонов и 
переопределением их методов. Например в `dicx` переопределены словарь и шаблон поиска. Для лучшего понимания нужно 
смотреть примеры предустановленных форматов и список основных компонентов в файле components.py.

### Конфигурация состоит из:
* *Уровень обработки*. Параметр `level`. Задается перечислением `ProcessLevel` — строка, предложение, слово, часть слова. 
"Часть слова", так же как и "слово" проверяет все слова, но дополнительно проверяет части, если слово окажется 
составным (Ростов-на-дону, Ростов, на, дону).
* *Загрузка данных*. Параметр `load`. Для загрузки текстовых файлов с разделителем "=" — структура `textfile_dictionary`.
Для загрузки из json-файла или базы данных необходимо реализовать самостоятельно, в связи с уникальностью
структуры хранения. Конфигурация состоит из:
* * *Загрузчик*. Параметр `loader`. Функция, поставщик данных для формирования правил. Позволяет загрузить их из 
    текстовых файлов содержащих правило на строку; из json-файла; из базы данных; из сети. Перечисление Loader
    содержит реализованные для загрузки из текстового файла и sqlite базы.
* * *Преобразователь*. Параметр `prepare`. Функция преобразующая данные полученные из загрузчика в два кортежа, 
    являющихся данными для создания шаблона поиска и текста замены. `Callable[[Any], tuple[TPatternData, TTargetData]]`
* *Конструктор словаря*. Параметр `dict_maker`. Конструктор класса отвечающего за отбор правил, которые надо 
применить к  обрабатываемой ноде, метод `rules_for`, и собственно их применение, метод `apply`.
Реализован обычный словарь, класс `Dictionary`, применяющий все правила последовательно и индексированный, 
класс `DictionaryIndex`, способный предварительно отфильтровать правила по определенному критерию.
* *Конструктор правила*. Параметр `rule_maker`. Реализованы классическое, класс `Rule`, заменяющее на константную
строку и класс `RuleResolved`, генерирующее замену динамически, для каждого обрабатываемого слова. Необходимо, 
например, для разрешения омографов. Ресолвер должен знать контекст обрабатываемого слова.
* *Конструктор шаблона поиска*. Параметр `pattern_maker`. Реализованы классы `PatternConst`, `PatternWildcard` и 
`PatternRe`. Пример переопределения смотри в формате `dicx`.
* *Конструктор шаблона замены*. Опциональный параметр `target_maker`. Если не указан, строкой замены будет 
константное значение. Пример смотри в формате `extw`.
